{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Before you turn this problem in, make sure everything runs as expected. First, **restart the kernel** (in the menubar, select Kernel$\\rightarrow$Restart) and then **run all cells** (in the menubar, select Cell$\\rightarrow$Run All).\n",
    "\n",
    "Note that this Pre-class Work is estimated to take **26 minutes**.\n",
    "\n",
    "Make sure you fill in any place that says `YOUR CODE HERE` or \"YOUR ANSWER HERE\", as well as your name and collaborators below:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "metadata": {},
   "outputs": [],
   "source": [
    "NAME = \"Simon Andren\"\n",
    "COLLABORATORS = \"N/A\""
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "---"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "nbgrader": {
     "checksum": "df135f0c4ea26cc7c0b25cb64a20e634",
     "grade": false,
     "grade_id": "cell-b46066345313bea6",
     "locked": true,
     "schema_version": 1,
     "solution": false
    }
   },
   "source": [
    "# CS110 Pre-class Work - Writing algorithms in Python--part I\n",
    "\n",
    "## Question 1 [time estimate: 10 minutes]\n",
    "\n",
    "Palindromes are a sequence of characters (words, phrases, numbers) that can be read the same both from left to right and from right to left. Examples of palindromes include the word 'madam' and the number 12321.\n",
    "\n",
    "1. Explain how you would use an iterative approach, step by step, to check whether a word is a palindrome.\n",
    "2. Explain also how you would approach this problem using a recursive solution.\n",
    "\n",
    "You can use palindromic and non-palindromic words to assist your explanation. "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "nbgrader": {
     "checksum": "104f443d240e2139d778711f6bc0a766",
     "grade": true,
     "grade_id": "cell-3bac59ff24b11a27",
     "locked": false,
     "points": 0,
     "schema_version": 1,
     "solution": true
    }
   },
   "source": [
    "1. To check if an input instance is a palindrome using a iterative approach I would start by building it as a for loop. The algorithm would loop over the first half of all the letters, rounding up if there was an odd amound of letter. If would then start by comparing the first letter in the word to the last letter in the word. If the letters match, we would simply continue to check the second letter to the second to last letter and so on. If the letters doesn't match, we would realize that this was not an palindrome and we would stop matching any further. However, if we have gone over half of all the letters with a match, we would stop and conclude it was a palindrome. \n",
    "\n",
    "2. Using a recursive solution to check if a input is a palindrome I would use an approach that also matches a letter with a certain position in a word to a letter with the same position but from the end. If the letters are the same, the algorithm would then strip the word of it's first and last letter. For example, 12321 would become 232 in a match. If there wasn't any match in the last and second to last letter, we would conclude that the word wasn't an palindrome. If there is no letter left in the word, after calling the recursive function, then we would conclude that we have a palindrome."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "nbgrader": {
     "checksum": "7872c2d656a6cb3aaeff2b4fa41eb204",
     "grade": false,
     "grade_id": "cell-0ca65d04b209f37f",
     "locked": true,
     "schema_version": 1,
     "solution": false
    }
   },
   "source": [
    "## Question 2 [time estimate: 3 minutes]\n",
    "\n",
    "How would you prevent your recursive solution from running forever? In other words, what is the base case of your recursive approach?"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "nbgrader": {
     "checksum": "4ff5af35daed9a5442ba229263bdde33",
     "grade": true,
     "grade_id": "cell-442998d5fdd8b561",
     "locked": false,
     "points": 0,
     "schema_version": 1,
     "solution": true
    }
   },
   "source": [
    "The base-line for the recursive approach would be that if there is no letters left in the word (len(word)==0)\n",
    "then we would conclude that the word isn't an palindrome. Eventually, all palindromes would have no letters left."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "nbgrader": {
     "checksum": "9d7a3b260b0fef93382fb52aa393f963",
     "grade": false,
     "grade_id": "cell-0ac1c20b43acb363",
     "locked": true,
     "schema_version": 1,
     "solution": false
    }
   },
   "source": [
    "## Question 3 [time estimate: 3 minutes]\n",
    "\n",
    "Is there a base case in an iterative approach? Why or why not?"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "nbgrader": {
     "checksum": "eb02c9951e19ee43d128fa93dd53eaad",
     "grade": true,
     "grade_id": "cell-5ecb51404140cb2f",
     "locked": false,
     "points": 0,
     "schema_version": 1,
     "solution": true
    }
   },
   "source": [
    "There is a base case in the iterative approach. In a while loop, the base case is that if we are matching a letter that exist on the second half of the word, then we have checked all the letters needing to be checked and the conditions have been met.\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": false,
    "editable": false,
    "nbgrader": {
     "checksum": "cb0b8b9c4b153530d47b437baa24098d",
     "grade": false,
     "grade_id": "cell-b22dce6b32afe1a9",
     "locked": true,
     "schema_version": 1,
     "solution": false
    }
   },
   "source": [
    "## Question 4 [time estimate: 10 minutes]\n",
    "\n",
    "Given the algorithmic strategies you described in question 1, you will now implement these in Python code. Write a function for the iterative approach (using either a `for` or a `while` loop) and another function for the recursive approach. Both functions should return `True` if the provided word is a palindrome, and `False` if the word is not. \n",
    "\n",
    "Validate the correctness of your code by providing examples of words that can be used as test cases. Be prepared to paste your functions and Palindrome words you searched into a Minerva workbook during class."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 34,
   "metadata": {
    "deletable": false,
    "nbgrader": {
     "checksum": "16ff8874250907a794fdd3fa6c13bbec",
     "grade": false,
     "grade_id": "cell-b709733c96d8b615",
     "locked": false,
     "schema_version": 1,
     "solution": true
    }
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "True\n",
      "False\n",
      "True\n"
     ]
    }
   ],
   "source": [
    "def is_palindrome_iterative(word):\n",
    "    \"\"\"\n",
    "    This function identifies whether a word is a palindrome iteratively.\n",
    "\n",
    "    Parameters\n",
    "    ----------\n",
    "    word : str\n",
    "        Word we wish to check\n",
    "    \n",
    "    Returns\n",
    "    -------\n",
    "    bool\n",
    "        True if input is a palindrome, False otherwise\n",
    "        \n",
    "    \"\"\"\n",
    "    for i in range(round((len(word)+1)//2)): #loops through half of the letters in the input word.\n",
    "                                            #If odd number of letters, includes the middle letter\n",
    "        if word[i] != word[-i-1]:  #If a letter doesn't match, returns False from the function\n",
    "            return False\n",
    "    \n",
    "    return True #If all the letters matches, it returns True\n",
    "        \n",
    "    raise NotImplementedError()\n",
    "\n",
    "print(is_palindrome_iterative(\"HeeH\"))\n",
    "print(is_palindrome_iterative(\"Heeh\"))\n",
    "print(is_palindrome_iterative(\"1HeH1\"))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 87,
   "metadata": {
    "deletable": false,
    "nbgrader": {
     "checksum": "16ff8874250907a794fdd3fa6c13bbec",
     "grade": false,
     "grade_id": "cell-b709733c96d8b615",
     "locked": false,
     "schema_version": 1,
     "solution": true
    }
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "True"
      ]
     },
     "execution_count": 87,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "def is_palindrome_recursive(word):\n",
    "    \"\"\"\n",
    "    This function identifies whether a word is a palindrome recursively.\n",
    "\n",
    "    Parameters\n",
    "    ----------\n",
    "    word : str\n",
    "        Word we wish to check\n",
    "    \n",
    "    Returns\n",
    "    -------\n",
    "    boolean\n",
    "        True if input is a palindrome, False otherwise\n",
    "        \n",
    "    \"\"\"\n",
    "    if len(word) > 0: #If there is letters left in the word\n",
    "        if word[0] == word[-1]: #If the last and first letter matches\n",
    "            is_palindrome_recursive(word[1:-1]) #Calls it self again but without the first and last letter\n",
    "        else:\n",
    "            return False #If it doesn't match, return False\n",
    "    return True #If there is no letters left, returns True\n",
    "\n",
    "        \n",
    "\n",
    "    raise NotImplementedError()\n",
    "\n",
    "is_palindrome_recursive(\"HeH\")\n",
    "#is_palindrome_recursive(\"Hej\")\n",
    "#is_palindrome_recursive(\"AHeHA\")\n",
    "#is_palindrome_recursive(\"MadaM\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "celltoolbar": "Edit Metadata",
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.6.5"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
